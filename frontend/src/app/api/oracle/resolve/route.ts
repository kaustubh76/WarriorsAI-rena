/**
 * API Route: Oracle Resolution
 * Handles AI-powered battle resolution via 0G Oracle
 */

import { NextRequest, NextResponse } from 'next/server';
import { type Address } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import {
  createFlowPublicClientForKey,
  createFlowFallbackClient,
  createFlowWalletClient,
  executeWithFlowFallbackForKey,
  RPC_TIMEOUT,
} from '@/lib/flowClient';
import { RateLimitPresets, ErrorResponses } from '@/lib/api';
import { composeMiddleware, withRateLimit } from '@/lib/api/middleware';

// Resolution outcome type
type ResolutionOutcome = 'yes' | 'no' | 'draw';

interface ResolutionRequest {
  battleId: string;
  marketId: string;
  warrior1Damage: string;
  warrior2Damage: string;
}

interface ResolutionResponse {
  success: boolean;
  battleId: string;
  marketId: string;
  outcome: ResolutionOutcome;
  proofHash: string;
  signatures: string[];
  txHash?: string;
  error?: string;
}

// ZeroGOracle ABI (key functions)
const ZeroGOracleABI = [
  {
    type: 'function',
    name: 'submitResolution',
    inputs: [
      { name: 'marketId', type: 'uint256' },
      { name: 'outcome', type: 'uint8' },
      { name: 'aiSignatures', type: 'bytes[]' },
      { name: 'proofHash', type: 'bytes32' }
    ],
    outputs: [],
    stateMutability: 'nonpayable'
  }
] as const;

export const POST = composeMiddleware([
  withRateLimit({ prefix: 'oracle-resolve', ...RateLimitPresets.agentOperations }),
  async (req, ctx) => {
    const body: ResolutionRequest = await req.json();
    const { battleId, marketId, warrior1Damage, warrior2Damage } = body;

    // Validate input
    if (!battleId || !marketId || !warrior1Damage || !warrior2Damage) {
      throw ErrorResponses.badRequest('Missing required fields');
    }

    // Determine outcome based on damage
    const damage1 = BigInt(warrior1Damage);
    const damage2 = BigInt(warrior2Damage);

    let outcome: ResolutionOutcome;
    let outcomeValue: number;

    if (damage1 < damage2) {
      outcome = 'yes'; // Warrior 1 wins (less damage)
      outcomeValue = 1;
    } else if (damage1 > damage2) {
      outcome = 'no'; // Warrior 2 wins
      outcomeValue = 2;
    } else {
      outcome = 'draw';
      outcomeValue = 3;
    }

    // Generate AI signatures (simulate multi-AI consensus)
    // In production, this would query actual 0G AI providers
    const signatures = await generateAISignatures(
      BigInt(battleId),
      BigInt(marketId),
      damage1,
      damage2,
      outcome
    );

    // Generate proof hash
    const proofHash = generateProofHash(
      BigInt(marketId),
      outcomeValue,
      signatures
    );

    // Optionally submit to contract if oracle key is configured
    let txHash: string | undefined;
    const oraclePrivateKey = process.env.ORACLE_SIGNER_PRIVATE_KEY;

    if (oraclePrivateKey) {
      try {
        txHash = await submitToContract(
          BigInt(marketId),
          outcomeValue,
          signatures,
          proofHash,
          oraclePrivateKey as `0x${string}`
        );
      } catch (txError) {
        console.error('Failed to submit to contract:', txError);
        // Continue - return the proof even if on-chain submission fails
      }
    }

    const response: ResolutionResponse = {
      success: true,
      battleId,
      marketId,
      outcome,
      proofHash,
      signatures,
      txHash
    };

    return NextResponse.json(response);
  },
], { errorContext: 'API:Oracle:Resolve:POST' });

/**
 * Generate simulated AI signatures from multiple providers
 * In production, this would query actual 0G Compute endpoints
 */
async function generateAISignatures(
  battleId: bigint,
  marketId: bigint,
  damage1: bigint,
  damage2: bigint,
  outcome: ResolutionOutcome
): Promise<string[]> {
  // Simulate 3 AI providers reaching consensus
  const providers = ['0G-GPT-4', '0G-Claude', '0G-Gemini'];
  const signatures: string[] = [];

  for (const provider of providers) {
    // In production, each signature would be generated by the actual AI provider
    // using their attestation key after verifying the battle data
    const signature = `0x${Buffer.from(
      JSON.stringify({
        provider,
        battleId: battleId.toString(),
        marketId: marketId.toString(),
        outcome,
        timestamp: Date.now()
      })
    ).toString('hex')}`;

    signatures.push(signature);
  }

  return signatures;
}

/**
 * Generate proof hash for on-chain verification
 */
function generateProofHash(
  marketId: bigint,
  outcome: number,
  signatures: string[]
): string {
  // Simple hash for demo - in production use proper encoding
  const data = JSON.stringify({
    marketId: marketId.toString(),
    outcome,
    sigCount: signatures.length,
    timestamp: Date.now()
  });

  // Convert to hex hash
  const hash = Buffer.from(data).toString('hex');
  return `0x${hash.padEnd(64, '0').slice(0, 64)}`;
}

/**
 * Submit resolution to the ZeroGOracle contract
 */
async function submitToContract(
  marketId: bigint,
  outcome: number,
  signatures: string[],
  proofHash: string,
  privateKey: `0x${string}`
): Promise<string> {
  const account = privateKeyToAccount(privateKey);
  const routingKey = `oracle-market-${marketId.toString()}`;

  const walletClient = createFlowWalletClient(account);
  const publicClient = createFlowPublicClientForKey(routingKey);
  const fallbackClient = createFlowFallbackClient();

  // Oracle contract address - update after deployment
  const oracleAddress = process.env.ZERO_G_ORACLE_ADDRESS as Address;

  if (!oracleAddress) {
    throw new Error('ZERO_G_ORACLE_ADDRESS not configured');
  }

  // Convert signatures to bytes
  const signaturesBytes = signatures.map(s => s as `0x${string}`);

  // Simulate via hash-ring-routed client
  const { request } = await executeWithFlowFallbackForKey(routingKey, (client) =>
    client.simulateContract({
      address: oracleAddress,
      abi: ZeroGOracleABI,
      functionName: 'submitResolution',
      args: [marketId, outcome, signaturesBytes, proofHash as `0x${string}`],
      account
    })
  );

  const hash = await walletClient.writeContract(request);

  // Wait for confirmation with fallback
  try {
    await publicClient.waitForTransactionReceipt({ hash, timeout: RPC_TIMEOUT });
  } catch (error) {
    const errMsg = (error as Error).message || '';
    if (errMsg.includes('timeout') || errMsg.includes('timed out') || errMsg.includes('TimeoutError')) {
      console.warn('[Oracle Resolve] Primary RPC timed out waiting for receipt, trying fallback...');
      await fallbackClient.waitForTransactionReceipt({ hash, timeout: RPC_TIMEOUT });
    } else {
      throw error;
    }
  }

  return hash;
}

// GET endpoint for checking resolution status
export const GET = composeMiddleware([
  withRateLimit({ prefix: 'oracle-resolve-get', ...RateLimitPresets.apiQueries }),
  async (req, ctx) => {
    const { searchParams } = new URL(req.url);
    const marketId = searchParams.get('marketId');

    if (!marketId) {
      throw ErrorResponses.badRequest('marketId is required');
    }

    // In production, fetch status from contract
    return NextResponse.json({
      marketId,
      status: 'pending',
      message: 'Resolution status check - implement contract read'
    });
  },
], { errorContext: 'API:Oracle:Resolve:GET' });
