/**
 * API Route: Oracle Resolution
 * Handles AI-powered battle resolution via 0G Oracle
 */

import { NextRequest, NextResponse } from 'next/server';
import { createPublicClient, createWalletClient, http, type Address } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { flowTestnet } from 'viem/chains';
import { getFlowRpcUrl, getFlowFallbackRpcUrl } from '@/constants';

// RPC timeout configuration
const RPC_TIMEOUT = 60000;

// Resolution outcome type
type ResolutionOutcome = 'yes' | 'no' | 'draw';

interface ResolutionRequest {
  battleId: string;
  marketId: string;
  warrior1Damage: string;
  warrior2Damage: string;
}

interface ResolutionResponse {
  success: boolean;
  battleId: string;
  marketId: string;
  outcome: ResolutionOutcome;
  proofHash: string;
  signatures: string[];
  txHash?: string;
  error?: string;
}

// ZeroGOracle ABI (key functions)
const ZeroGOracleABI = [
  {
    type: 'function',
    name: 'submitResolution',
    inputs: [
      { name: 'marketId', type: 'uint256' },
      { name: 'outcome', type: 'uint8' },
      { name: 'aiSignatures', type: 'bytes[]' },
      { name: 'proofHash', type: 'bytes32' }
    ],
    outputs: [],
    stateMutability: 'nonpayable'
  }
] as const;

export async function POST(request: NextRequest) {
  try {
    const body: ResolutionRequest = await request.json();
    const { battleId, marketId, warrior1Damage, warrior2Damage } = body;

    // Validate input
    if (!battleId || !marketId || !warrior1Damage || !warrior2Damage) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Determine outcome based on damage
    const damage1 = BigInt(warrior1Damage);
    const damage2 = BigInt(warrior2Damage);

    let outcome: ResolutionOutcome;
    let outcomeValue: number;

    if (damage1 < damage2) {
      outcome = 'yes'; // Warrior 1 wins (less damage)
      outcomeValue = 1;
    } else if (damage1 > damage2) {
      outcome = 'no'; // Warrior 2 wins
      outcomeValue = 2;
    } else {
      outcome = 'draw';
      outcomeValue = 3;
    }

    // Generate AI signatures (simulate multi-AI consensus)
    // In production, this would query actual 0G AI providers
    const signatures = await generateAISignatures(
      BigInt(battleId),
      BigInt(marketId),
      damage1,
      damage2,
      outcome
    );

    // Generate proof hash
    const proofHash = generateProofHash(
      BigInt(marketId),
      outcomeValue,
      signatures
    );

    // Optionally submit to contract if oracle key is configured
    let txHash: string | undefined;
    const oraclePrivateKey = process.env.ORACLE_SIGNER_PRIVATE_KEY;

    if (oraclePrivateKey) {
      try {
        txHash = await submitToContract(
          BigInt(marketId),
          outcomeValue,
          signatures,
          proofHash,
          oraclePrivateKey as `0x${string}`
        );
      } catch (txError) {
        console.error('Failed to submit to contract:', txError);
        // Continue - return the proof even if on-chain submission fails
      }
    }

    const response: ResolutionResponse = {
      success: true,
      battleId,
      marketId,
      outcome,
      proofHash,
      signatures,
      txHash
    };

    return NextResponse.json(response);
  } catch (error) {
    console.error('Oracle resolution error:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

/**
 * Generate simulated AI signatures from multiple providers
 * In production, this would query actual 0G Compute endpoints
 */
async function generateAISignatures(
  battleId: bigint,
  marketId: bigint,
  damage1: bigint,
  damage2: bigint,
  outcome: ResolutionOutcome
): Promise<string[]> {
  // Simulate 3 AI providers reaching consensus
  const providers = ['0G-GPT-4', '0G-Claude', '0G-Gemini'];
  const signatures: string[] = [];

  for (const provider of providers) {
    // In production, each signature would be generated by the actual AI provider
    // using their attestation key after verifying the battle data
    const signature = `0x${Buffer.from(
      JSON.stringify({
        provider,
        battleId: battleId.toString(),
        marketId: marketId.toString(),
        outcome,
        timestamp: Date.now()
      })
    ).toString('hex')}`;

    signatures.push(signature);
  }

  return signatures;
}

/**
 * Generate proof hash for on-chain verification
 */
function generateProofHash(
  marketId: bigint,
  outcome: number,
  signatures: string[]
): string {
  // Simple hash for demo - in production use proper encoding
  const data = JSON.stringify({
    marketId: marketId.toString(),
    outcome,
    sigCount: signatures.length,
    timestamp: Date.now()
  });

  // Convert to hex hash
  const hash = Buffer.from(data).toString('hex');
  return `0x${hash.padEnd(64, '0').slice(0, 64)}`;
}

/**
 * Submit resolution to the ZeroGOracle contract
 */
async function submitToContract(
  marketId: bigint,
  outcome: number,
  signatures: string[],
  proofHash: string,
  privateKey: `0x${string}`
): Promise<string> {
  const account = privateKeyToAccount(privateKey);

  const walletClient = createWalletClient({
    account,
    chain: flowTestnet,
    transport: http(getFlowRpcUrl(), { timeout: RPC_TIMEOUT, retryCount: 2, retryDelay: 1000 })
  });

  const publicClient = createPublicClient({
    chain: flowTestnet,
    transport: http(getFlowRpcUrl(), { timeout: RPC_TIMEOUT, retryCount: 2, retryDelay: 1000 })
  });

  const fallbackPublicClient = createPublicClient({
    chain: flowTestnet,
    transport: http(getFlowFallbackRpcUrl(), { timeout: RPC_TIMEOUT, retryCount: 2, retryDelay: 1000 })
  });

  // Helper to check if error is timeout
  const isTimeoutError = (error: unknown): boolean => {
    const errMsg = (error as Error).message || '';
    return errMsg.includes('timeout') ||
           errMsg.includes('timed out') ||
           errMsg.includes('took too long') ||
           errMsg.includes('TimeoutError');
  };

  // Oracle contract address - update after deployment
  const oracleAddress = process.env.ZERO_G_ORACLE_ADDRESS as Address;

  if (!oracleAddress) {
    throw new Error('ZERO_G_ORACLE_ADDRESS not configured');
  }

  // Convert signatures to bytes
  const signaturesBytes = signatures.map(s => s as `0x${string}`);

  const { request } = await publicClient.simulateContract({
    address: oracleAddress,
    abi: ZeroGOracleABI,
    functionName: 'submitResolution',
    args: [marketId, outcome, signaturesBytes, proofHash as `0x${string}`],
    account
  });

  const hash = await walletClient.writeContract(request);

  // Wait for confirmation with fallback
  try {
    await publicClient.waitForTransactionReceipt({ hash, timeout: RPC_TIMEOUT });
  } catch (error) {
    if (isTimeoutError(error)) {
      console.warn('[Oracle Resolve] Primary RPC timed out waiting for receipt, trying fallback...');
      await fallbackPublicClient.waitForTransactionReceipt({ hash, timeout: RPC_TIMEOUT });
    } else {
      throw error;
    }
  }

  return hash;
}

// GET endpoint for checking resolution status
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const marketId = searchParams.get('marketId');

  if (!marketId) {
    return NextResponse.json(
      { error: 'marketId is required' },
      { status: 400 }
    );
  }

  // In production, fetch status from contract
  return NextResponse.json({
    marketId,
    status: 'pending',
    message: 'Resolution status check - implement contract read'
  });
}
