/**
 * AI Agent Trading Service
 * Executes trades on prediction markets using verified 0G AI inference
 *
 * CRITICAL: This service ensures that all AI agent predictions are:
 * 1. Generated by verified 0G Compute providers
 * 2. Cryptographically hashed for on-chain verification
 * 3. Stored on 0G Storage for audit trails
 * 4. Only executed on-chain if verification passes
 */

import type { Address } from 'viem';
import { parseEther, formatEther } from 'viem';
import predictionMarketService, { type Market, MarketStatus } from './predictionMarketService';
import aiAgentService from './aiAgentService';
import { zeroGStorageService } from './zeroGStorageService';
import { warriorsNFTService } from './warriorsNFTService';
import type { BattleDataIndex } from '../types/zeroG';

// ============================================================================
// Types
// ============================================================================

export interface TradingPrediction {
  marketId: bigint;
  agentId: bigint;
  isYes: boolean;
  confidence: number;
  reasoning: string;
  isVerified: boolean;
  fallbackMode: boolean;
  chatId: string;
  proof: {
    inputHash: string;
    outputHash: string;
    providerAddress: Address;
    modelHash: string;
  };
  timestamp: number;
}

export interface TradeExecutionResult {
  success: boolean;
  txHash?: string;
  error?: string;
  prediction?: TradingPrediction;
  amount?: string;
  sharesReceived?: string;
}

export interface AgentTradingConfig {
  agentId: bigint;
  maxTradeAmount: bigint;
  minConfidence: number;
  autoExecute: boolean;
  onlyVerified: boolean;  // CRITICAL: Only trade with verified 0G predictions
}

// ============================================================================
// Service Class
// ============================================================================

class AIAgentTradingService {
  private readonly minConfidenceThreshold = 60; // Minimum confidence to trade
  private readonly requireVerification = true;   // CRITICAL: Require 0G verification

  /**
   * Generate AI prediction for a market using 0G Compute
   * CRITICAL: Returns verification status - unverified predictions should NOT be traded
   */
  async generatePrediction(
    marketId: bigint,
    agentId: bigint
  ): Promise<TradingPrediction | null> {
    try {
      // Get market data
      const market = await predictionMarketService.getMarket(marketId);
      if (!market || market.status !== MarketStatus.Active) {
        console.error('Market not active or not found');
        return null;
      }

      // Get agent data
      const agent = await aiAgentService.getAgent(agentId);
      if (!agent || !agent.isActive) {
        console.error('Agent not active or not found');
        return null;
      }

      // Build battle data from market
      const battleData = await this.buildBattleData(market);

      // Get historical context from 0G storage
      const historicalContext = await zeroGStorageService.getBattleContext(
        market.warrior1Id,
        market.warrior2Id,
        5
      );

      // Build prompt for 0G inference
      const prompt = this.buildTradingPrompt(market, battleData, agent, historicalContext);

      // Call 0G inference API
      const response = await fetch('/api/0g/inference', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          maxTokens: 1000,
          temperature: 0.5, // Lower temperature for more consistent predictions
          battleData: {
            battleId: market.battleId.toString(),
            warriors: battleData.warriors.map(w => ({
              id: w.id.toString(),
              traits: w.traits
            }))
          }
        })
      });

      const result = await response.json();

      // CRITICAL: Check verification status
      if (!response.ok || !result.success) {
        console.error('0G inference failed:', result.error);
        return null;
      }

      // Parse the prediction
      const parsed = this.parseAIResponse(result.response);

      return {
        marketId,
        agentId,
        isYes: parsed.outcome === 'yes',
        confidence: parsed.confidence,
        reasoning: parsed.reasoning,
        isVerified: result.isVerified === true,
        fallbackMode: result.fallbackMode === true,
        chatId: result.chatId,
        proof: result.proof,
        timestamp: Date.now()
      };
    } catch (error) {
      console.error('Error generating prediction:', error);
      return null;
    }
  }

  /**
   * Validate a prediction before execution
   * CRITICAL: This ensures only verified predictions are executed on-chain
   */
  validatePrediction(prediction: TradingPrediction): {
    valid: boolean;
    reasons: string[];
  } {
    const reasons: string[] = [];

    // CRITICAL: Require 0G verification
    if (this.requireVerification && !prediction.isVerified) {
      reasons.push('Prediction is not verified by 0G Compute');
    }

    // Reject fallback predictions
    if (prediction.fallbackMode) {
      reasons.push('Prediction is in fallback mode (not from real 0G provider)');
    }

    // Check confidence threshold
    if (prediction.confidence < this.minConfidenceThreshold) {
      reasons.push(`Confidence ${prediction.confidence}% is below minimum ${this.minConfidenceThreshold}%`);
    }

    // Verify proof exists
    if (!prediction.proof || !prediction.proof.outputHash) {
      reasons.push('No cryptographic proof available');
    }

    // Verify provider address
    if (!prediction.proof?.providerAddress ||
        prediction.proof.providerAddress === '0x0000000000000000000000000000000000000000') {
      reasons.push('Invalid provider address');
    }

    return {
      valid: reasons.length === 0,
      reasons
    };
  }

  /**
   * Execute trade on behalf of agent using server wallet
   * CRITICAL: This method sends the trade to the server for execution
   */
  async executeAgentTrade(
    prediction: TradingPrediction,
    amount: bigint
  ): Promise<TradeExecutionResult> {
    try {
      console.log(`[AgentTrading] Executing server-side trade for agent #${prediction.agentId}`);
      console.log(`   Market: #${prediction.marketId}, Position: ${prediction.isYes ? 'YES' : 'NO'}`);
      console.log(`   Amount: ${formatEther(amount)} CRwN, Confidence: ${prediction.confidence}%`);

      const response = await fetch('/api/agents/execute-trade', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          agentId: prediction.agentId.toString(),
          marketId: prediction.marketId.toString(),
          isYes: prediction.isYes,
          amount: amount.toString(),
          prediction
        })
      });

      const result = await response.json();

      if (!result.success) {
        console.error('[AgentTrading] Trade execution failed:', result.error);
        return {
          success: false,
          error: result.error || 'Trade execution failed',
          prediction
        };
      }

      console.log(`[AgentTrading] âœ… Trade executed successfully!`);
      console.log(`   TX Hash: ${result.txHash}`);

      return {
        success: true,
        txHash: result.txHash,
        prediction,
        amount: formatEther(amount)
      };
    } catch (error) {
      console.error('[AgentTrading] Error executing trade:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        prediction
      };
    }
  }

  /**
   * Get agent trading status (wallet balance, rate limits, etc.)
   */
  async getAgentTradingStatus(agentId?: bigint): Promise<{
    success: boolean;
    wallet?: { address: string; crwnBalance: string; nativeBalance: string };
    limits?: { maxTradeAmount: string; minConfidence: number };
    rateLimit?: { remaining: number; resetIn: number } | null;
    error?: string;
  }> {
    try {
      const url = agentId
        ? `/api/agents/execute-trade?agentId=${agentId.toString()}`
        : '/api/agents/execute-trade';

      const response = await fetch(url, { method: 'GET' });
      const result = await response.json();

      if (!result.success) {
        console.error('[AgentTrading] Failed to get status:', result.error);
        return { success: false, error: result.error };
      }

      return result;
    } catch (error) {
      console.error('[AgentTrading] Error getting status:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  /**
   * Store prediction on 0G for audit trail
   */
  async storePrediction(prediction: TradingPrediction): Promise<string | null> {
    try {
      const response = await fetch('/api/0g/store', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          battle: {
            battleId: `prediction_${prediction.marketId}_${prediction.agentId}_${prediction.timestamp}`,
            timestamp: prediction.timestamp,
            warriors: [],
            rounds: [],
            outcome: prediction.isYes ? 'warrior1' : 'warrior2',
            totalDamage: { warrior1: 0, warrior2: 0 },
            totalRounds: 0,
            _predictionData: {
              marketId: prediction.marketId.toString(),
              agentId: prediction.agentId.toString(),
              isYes: prediction.isYes,
              confidence: prediction.confidence,
              reasoning: prediction.reasoning,
              chatId: prediction.chatId,
              proof: prediction.proof,
              isVerified: prediction.isVerified
            }
          }
        })
      });

      if (response.ok) {
        const result = await response.json();
        return result.rootHash;
      }
    } catch (error) {
      console.error('Failed to store prediction:', error);
    }
    return null;
  }

  /**
   * Get trade recommendation based on prediction
   */
  getTradeRecommendation(prediction: TradingPrediction, maxAmount: bigint): {
    shouldTrade: boolean;
    position: 'yes' | 'no';
    amount: bigint;
    reasons: string[];
  } {
    const validation = this.validatePrediction(prediction);

    if (!validation.valid) {
      return {
        shouldTrade: false,
        position: prediction.isYes ? 'yes' : 'no',
        amount: BigInt(0),
        reasons: validation.reasons
      };
    }

    // Scale amount based on confidence
    const confidenceMultiplier = prediction.confidence / 100;
    const scaledAmount = BigInt(Math.floor(Number(maxAmount) * confidenceMultiplier));

    return {
      shouldTrade: true,
      position: prediction.isYes ? 'yes' : 'no',
      amount: scaledAmount,
      reasons: [`Verified prediction with ${prediction.confidence}% confidence`]
    };
  }

  /**
   * Build battle data from market for prediction
   * Fetches real warrior data from the WarriorsNFT contract with fallback
   */
  private async buildBattleData(market: Market): Promise<BattleDataIndex> {
    // Helper to create default warrior data
    const createDefaultWarrior = (warriorId: bigint, index: number) => ({
      id: warriorId,
      name: warriorId > BigInt(0) ? `Warrior #${warriorId}` : `Warrior ${index + 1}`,
      traits: { strength: 50, wit: 50, charisma: 50, defence: 50, luck: 50 },
      totalBattles: 0,
      wins: 0,
      losses: 0
    });

    // Helper to fetch warrior data with fallback
    const getWarriorData = async (warriorId: bigint, index: number) => {
      // Validate warrior ID - ERC721 tokens start at 1, ID 0 is invalid
      if (!warriorId || warriorId === BigInt(0)) {
        console.warn(`Invalid warrior ID ${warriorId}, using defaults`);
        return createDefaultWarrior(warriorId, index);
      }

      try {
        const details = await warriorsNFTService.getWarriorsDetails(Number(warriorId));
        return {
          id: warriorId,
          name: details.name,
          traits: details.traits,
          totalBattles: 0, // Historical data not available from contract
          wins: 0,
          losses: 0
        };
      } catch (error) {
        console.warn(`Failed to fetch warrior ${warriorId}, using defaults:`, error);
        return createDefaultWarrior(warriorId, index);
      }
    };

    // Fetch both warriors in parallel
    const [warrior1, warrior2] = await Promise.all([
      getWarriorData(market.warrior1Id, 0),
      getWarriorData(market.warrior2Id, 1)
    ]);

    return {
      battleId: market.battleId,
      timestamp: Number(market.createdAt) * 1000,
      warriors: [warrior1, warrior2],
      rounds: [],
      outcome: 'draw',
      totalDamage: { warrior1: 0, warrior2: 0 },
      totalRounds: 0
    };
  }

  /**
   * Build trading prompt for 0G inference
   */
  private buildTradingPrompt(
    market: Market,
    battleData: BattleDataIndex,
    agent: any,
    context: BattleDataIndex[]
  ): string {
    const w1 = battleData.warriors[0];
    const w2 = battleData.warriors[1];

    let prompt = `
You are an AI trading agent for the Warriors AI Arena prediction market.
Your strategy is: ${agent.strategy}
Your risk profile is: ${agent.riskProfile}

MARKET QUESTION: ${market.question}

CURRENT MARKET STATE:
- Yes probability: ${Number(market.yesTokens) / (Number(market.yesTokens) + Number(market.noTokens)) * 100}%
- Total volume: ${formatEther(market.totalVolume)} CRwN
- Liquidity: ${formatEther(market.liquidity)} CRwN

WARRIOR 1 (ID: ${w1.id}):
- Strength: ${w1.traits.strength}
- Wit: ${w1.traits.wit}
- Defence: ${w1.traits.defence}
- Luck: ${w1.traits.luck}
- Charisma: ${w1.traits.charisma}

WARRIOR 2 (ID: ${w2.id}):
- Strength: ${w2.traits.strength}
- Wit: ${w2.traits.wit}
- Defence: ${w2.traits.defence}
- Luck: ${w2.traits.luck}
- Charisma: ${w2.traits.charisma}
`;

    if (context.length > 0) {
      prompt += `\n\nHISTORICAL CONTEXT (${context.length} previous battles):`;
      for (const battle of context.slice(0, 3)) {
        prompt += `\n- Battle #${battle.battleId}: ${battle.outcome} after ${battle.totalRounds} rounds`;
      }
    }

    prompt += `

Based on your analysis, provide your trading prediction in JSON format:
{
  "outcome": "yes" | "no",
  "confidence": <number 0-100>,
  "reasoning": "<your detailed analysis explaining why you chose this position>"
}

IMPORTANT: Your prediction will be verified on-chain. Be accurate and provide clear reasoning.
`;

    return prompt;
  }

  /**
   * Parse AI response to extract prediction
   */
  private parseAIResponse(response: string): {
    outcome: 'yes' | 'no' | 'draw';
    confidence: number;
    reasoning: string;
  } {
    try {
      // Try direct parse
      const parsed = JSON.parse(response.trim());
      return {
        outcome: parsed.outcome || 'draw',
        confidence: parsed.confidence || 50,
        reasoning: parsed.reasoning || 'No reasoning provided'
      };
    } catch {
      // Try to extract from markdown
      const jsonMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
      if (jsonMatch) {
        try {
          const parsed = JSON.parse(jsonMatch[1].trim());
          return {
            outcome: parsed.outcome || 'draw',
            confidence: parsed.confidence || 50,
            reasoning: parsed.reasoning || 'No reasoning provided'
          };
        } catch {}
      }

      // Try to find JSON object
      const objectMatch = response.match(/\{[\s\S]*\}/);
      if (objectMatch) {
        try {
          const parsed = JSON.parse(objectMatch[0]);
          return {
            outcome: parsed.outcome || 'draw',
            confidence: parsed.confidence || 50,
            reasoning: parsed.reasoning || 'No reasoning provided'
          };
        } catch {}
      }

      return {
        outcome: 'draw',
        confidence: 50,
        reasoning: response
      };
    }
  }
}

export const aiAgentTradingService = new AIAgentTradingService();
export default aiAgentTradingService;
