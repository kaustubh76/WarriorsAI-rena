/**
 * AI Agent Trading Service
 * Executes trades on prediction markets using verified 0G AI inference
 *
 * CRITICAL: This service ensures that all AI agent predictions are:
 * 1. Generated by verified 0G Compute providers
 * 2. Cryptographically hashed for on-chain verification
 * 3. Stored on 0G Storage for audit trails
 * 4. Only executed on-chain if verification passes
 */

import type { Address } from 'viem';
import { parseEther, formatEther } from 'viem';
import predictionMarketService, { type Market, MarketStatus } from './predictionMarketService';
import aiAgentService from './aiAgentService';
import { agentINFTService } from './agentINFTService';
import { zeroGStorageService } from './zeroGStorageService';
import { warriorsNFTService } from './warriorsNFTService';
import type { BattleDataIndex } from '../types/zeroG';

// ============================================================================
// Types
// ============================================================================

export interface TradingPrediction {
  marketId: bigint;
  agentId: bigint;
  isYes: boolean;
  confidence: number;
  reasoning: string;
  isVerified: boolean;
  chatId: string;
  proof: {
    inputHash: string;
    outputHash: string;
    providerAddress: Address;
    modelHash: string;
  };
  timestamp: number;
}

export interface TradeExecutionResult {
  success: boolean;
  txHash?: string;
  error?: string;
  prediction?: TradingPrediction;
  amount?: string;
  sharesReceived?: string;
}

export interface AgentTradingConfig {
  agentId: bigint;
  maxTradeAmount: bigint;
  minConfidence: number;
  autoExecute: boolean;
  onlyVerified: boolean;  // CRITICAL: Only trade with verified 0G predictions
}

// ============================================================================
// Service Class
// ============================================================================

class AIAgentTradingService {
  private readonly minConfidenceThreshold = 60; // Minimum confidence to trade

  /**
   * Generate AI prediction for a market using 0G Compute
   * CRITICAL: Returns verification status - unverified predictions should NOT be traded
   */
  async generatePrediction(
    marketId: bigint,
    agentId: bigint
  ): Promise<TradingPrediction | null> {
    try {
      // Get market data
      const market = await predictionMarketService.getMarket(marketId);
      if (!market || market.status !== MarketStatus.Active) {
        console.error('Market not active or not found');
        return null;
      }

      // Get agent data - try iNFT first (0G chain), then legacy registry (Flow chain)
      let agent: { id: bigint; strategy: number; riskProfile: number; isActive: boolean } | null = null;

      // First try iNFT service (agents are primarily iNFTs now)
      const inft = await agentINFTService.getINFT(agentId);
      if (inft && inft.onChainData.isActive) {
        agent = {
          id: agentId,
          strategy: 0, // Strategy is encrypted in iNFT metadata
          riskProfile: 1, // Risk profile is encrypted in iNFT metadata
          isActive: inft.onChainData.isActive
        };
        console.log(`[Trading] Using iNFT agent #${agentId}`);
      } else {
        // Fallback to legacy registry
        const legacyAgent = await aiAgentService.getAgent(agentId);
        if (legacyAgent && legacyAgent.isActive) {
          agent = {
            id: agentId,
            strategy: legacyAgent.strategy,
            riskProfile: legacyAgent.riskProfile,
            isActive: legacyAgent.isActive
          };
          console.log(`[Trading] Using legacy agent #${agentId}`);
        }
      }

      if (!agent || !agent.isActive) {
        console.error('Agent not active or not found');
        return null;
      }

      // Build battle data from market (handles warrior ID 0 gracefully)
      const battleData = await this.buildBattleData(market);

      // Get historical context from 0G storage (only if warriors exist)
      let historicalContext: BattleDataIndex[] = [];
      if (market.warrior1Id && market.warrior1Id !== BigInt(0) &&
          market.warrior2Id && market.warrior2Id !== BigInt(0)) {
        historicalContext = await zeroGStorageService.getBattleContext(
          market.warrior1Id,
          market.warrior2Id,
          5
        );
      }

      // Build prompt for 0G inference
      const prompt = this.buildTradingPrompt(market, battleData, agent, historicalContext);

      // Call 0G inference API
      const response = await fetch('/api/0g/inference', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          maxTokens: 1000,
          temperature: 0.5, // Lower temperature for more consistent predictions
          battleData: {
            battleId: market.battleId.toString(),
            warriors: battleData.warriors.map(w => ({
              id: w.id.toString(),
              traits: w.traits
            }))
          }
        })
      });

      const result = await response.json();

      // CRITICAL: Check verification status
      if (!response.ok || !result.success) {
        console.error('0G inference failed:', result.error);
        return null;
      }

      // Parse the prediction
      const parsed = this.parseAIResponse(result.response);

      return {
        marketId,
        agentId,
        isYes: parsed.outcome === 'yes',
        confidence: parsed.confidence,
        reasoning: parsed.reasoning,
        isVerified: result.isVerified === true,
        chatId: result.chatId,
        proof: result.proof,
        timestamp: Date.now()
      };
    } catch (error) {
      console.error('Error generating prediction:', error);
      return null;
    }
  }

  /**
   * Validate a prediction before execution
   * CRITICAL: This ensures only verified predictions are executed on-chain
   */
  validatePrediction(prediction: TradingPrediction): {
    valid: boolean;
    reasons: string[];
  } {
    const reasons: string[] = [];

    console.log('[Validation] Checking prediction:', {
      isVerified: prediction.isVerified,
      confidence: prediction.confidence,
      hasProof: !!prediction.proof,
      outputHash: prediction.proof?.outputHash,
      providerAddress: prediction.proof?.providerAddress
    });

    // Require 0G verification - no exceptions
    if (!prediction.isVerified) {
      reasons.push('Prediction is not verified by 0G Compute');
    }

    // Check confidence threshold
    if (prediction.confidence < this.minConfidenceThreshold) {
      reasons.push(`Confidence ${prediction.confidence}% is below minimum ${this.minConfidenceThreshold}%`);
    }

    // Verify proof exists
    if (!prediction.proof || !prediction.proof.outputHash) {
      reasons.push('No cryptographic proof available');
    }

    // Verify provider address
    if (!prediction.proof?.providerAddress ||
        prediction.proof.providerAddress === '0x0000000000000000000000000000000000000000') {
      reasons.push('Invalid provider address');
    }

    console.log('[Validation] Result:', { valid: reasons.length === 0, reasons });

    return {
      valid: reasons.length === 0,
      reasons
    };
  }

  /**
   * Execute trade on behalf of agent using server wallet
   * CRITICAL: This method sends the trade to the server for execution
   */
  async executeAgentTrade(
    prediction: TradingPrediction,
    amount: bigint
  ): Promise<TradeExecutionResult> {
    try {
      console.log(`[AgentTrading] Executing server-side trade for agent #${prediction.agentId}`);
      console.log(`   Market: #${prediction.marketId}, Position: ${prediction.isYes ? 'YES' : 'NO'}`);
      console.log(`   Amount: ${formatEther(amount)} CRwN, Confidence: ${prediction.confidence}%`);
      console.log(`   Verified: ${prediction.isVerified}, Proof: ${prediction.proof?.outputHash ? 'present' : 'missing'}`);

      // Serialize prediction properly (convert BigInt to string)
      const serializedPrediction = {
        marketId: prediction.marketId.toString(),
        agentId: prediction.agentId.toString(),
        isYes: prediction.isYes,
        confidence: prediction.confidence,
        reasoning: prediction.reasoning,
        isVerified: prediction.isVerified,
        chatId: prediction.chatId,
        proof: prediction.proof,
        timestamp: prediction.timestamp
      };

      const response = await fetch('/api/agents/execute-trade', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          agentId: prediction.agentId.toString(),
          marketId: prediction.marketId.toString(),
          isYes: prediction.isYes,
          amount: amount.toString(),
          prediction: serializedPrediction
        })
      });

      const result = await response.json();

      if (!result.success) {
        console.error('[AgentTrading] Trade execution failed:', result.error);
        return {
          success: false,
          error: result.error || 'Trade execution failed',
          prediction
        };
      }

      console.log(`[AgentTrading] âœ… Trade executed successfully!`);
      console.log(`   TX Hash: ${result.txHash}`);

      return {
        success: true,
        txHash: result.txHash,
        prediction,
        amount: formatEther(amount)
      };
    } catch (error) {
      console.error('[AgentTrading] Error executing trade:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        prediction
      };
    }
  }

  /**
   * Get agent trading status (wallet balance, rate limits, etc.)
   */
  async getAgentTradingStatus(agentId?: bigint): Promise<{
    success: boolean;
    wallet?: { address: string; crwnBalance: string; nativeBalance: string };
    limits?: { maxTradeAmount: string; minConfidence: number };
    rateLimit?: { remaining: number; resetIn: number } | null;
    error?: string;
  }> {
    try {
      const url = agentId
        ? `/api/agents/execute-trade?agentId=${agentId.toString()}`
        : '/api/agents/execute-trade';

      const response = await fetch(url, { method: 'GET' });
      const result = await response.json();

      if (!result.success) {
        console.error('[AgentTrading] Failed to get status:', result.error);
        return { success: false, error: result.error };
      }

      return result;
    } catch (error) {
      console.error('[AgentTrading] Error getting status:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  /**
   * Store prediction on 0G for audit trail
   */
  async storePrediction(prediction: TradingPrediction): Promise<string | null> {
    try {
      const response = await fetch('/api/0g/store', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          battle: {
            battleId: `prediction_${prediction.marketId}_${prediction.agentId}_${prediction.timestamp}`,
            timestamp: prediction.timestamp,
            warriors: [],
            rounds: [],
            outcome: prediction.isYes ? 'warrior1' : 'warrior2',
            totalDamage: { warrior1: 0, warrior2: 0 },
            totalRounds: 0,
            _predictionData: {
              marketId: prediction.marketId.toString(),
              agentId: prediction.agentId.toString(),
              isYes: prediction.isYes,
              confidence: prediction.confidence,
              reasoning: prediction.reasoning,
              chatId: prediction.chatId,
              proof: prediction.proof,
              isVerified: prediction.isVerified
            }
          }
        })
      });

      if (response.ok) {
        const result = await response.json();
        return result.rootHash;
      }
    } catch (error) {
      console.error('Failed to store prediction:', error);
    }
    return null;
  }

  /**
   * Get trade recommendation based on prediction
   */
  getTradeRecommendation(prediction: TradingPrediction, maxAmount: bigint): {
    shouldTrade: boolean;
    position: 'yes' | 'no';
    amount: bigint;
    reasons: string[];
  } {
    const validation = this.validatePrediction(prediction);

    if (!validation.valid) {
      return {
        shouldTrade: false,
        position: prediction.isYes ? 'yes' : 'no',
        amount: BigInt(0),
        reasons: validation.reasons
      };
    }

    // Use the maxAmount directly - confidence is already validated above threshold (60%)
    // Don't scale by confidence as this causes unexpected large trades
    // The validation ensures we only trade when confidence is sufficient

    return {
      shouldTrade: true,
      position: prediction.isYes ? 'yes' : 'no',
      amount: maxAmount,
      reasons: [`Verified prediction with ${prediction.confidence}% confidence`]
    };
  }

  /**
   * Build battle data from market for prediction
   * Fetches real warrior data from the WarriorsNFT contract with fallback
   * Handles generic prediction markets (warrior IDs = 0) gracefully
   */
  private async buildBattleData(market: Market): Promise<BattleDataIndex> {
    // Check if this is a battle market or a generic prediction market
    const isBattleMarket = market.warrior1Id && market.warrior1Id !== BigInt(0) &&
                           market.warrior2Id && market.warrior2Id !== BigInt(0);

    // Helper to create default warrior data for generic markets
    const createDefaultWarrior = (warriorId: bigint, index: number) => ({
      id: warriorId || BigInt(index + 1),
      name: warriorId > BigInt(0) ? `Warrior #${warriorId}` : `Option ${index === 0 ? 'Yes' : 'No'}`,
      traits: { strength: 50, wit: 50, charisma: 50, defence: 50, luck: 50 },
      totalBattles: 0,
      wins: 0,
      losses: 0
    });

    // For generic markets (no warriors), return placeholder data
    if (!isBattleMarket) {
      // This is a generic prediction market, not a warrior battle
      return {
        battleId: market.battleId || BigInt(0),
        timestamp: Number(market.createdAt) * 1000,
        warriors: [
          createDefaultWarrior(BigInt(0), 0),
          createDefaultWarrior(BigInt(0), 1)
        ],
        rounds: [],
        outcome: 'draw',
        totalDamage: { warrior1: 0, warrior2: 0 },
        totalRounds: 0
      };
    }

    // Helper to fetch warrior data with fallback
    const getWarriorData = async (warriorId: bigint, index: number) => {
      try {
        const details = await warriorsNFTService.getWarriorsDetails(Number(warriorId));
        return {
          id: warriorId,
          name: details.name,
          traits: details.traits,
          totalBattles: 0, // Historical data not available from contract
          wins: 0,
          losses: 0
        };
      } catch (error) {
        console.warn(`Failed to fetch warrior ${warriorId}, using defaults:`, error);
        return createDefaultWarrior(warriorId, index);
      }
    };

    // Fetch both warriors in parallel
    const [warrior1, warrior2] = await Promise.all([
      getWarriorData(market.warrior1Id, 0),
      getWarriorData(market.warrior2Id, 1)
    ]);

    return {
      battleId: market.battleId,
      timestamp: Number(market.createdAt) * 1000,
      warriors: [warrior1, warrior2],
      rounds: [],
      outcome: 'draw',
      totalDamage: { warrior1: 0, warrior2: 0 },
      totalRounds: 0
    };
  }

  /**
   * Build trading prompt for 0G inference
   * Handles both battle markets (with warriors) and generic prediction markets
   */
  private buildTradingPrompt(
    market: Market,
    battleData: BattleDataIndex,
    agent: any,
    context: BattleDataIndex[]
  ): string {
    const w1 = battleData.warriors[0];
    const w2 = battleData.warriors[1];

    // Check if this is a battle market or generic prediction
    const isBattleMarket = market.warrior1Id && market.warrior1Id !== BigInt(0);

    // Calculate yes probability safely
    const totalTokens = Number(market.yesTokens) + Number(market.noTokens);
    const yesProbability = totalTokens > 0
      ? (Number(market.yesTokens) / totalTokens * 100).toFixed(1)
      : '50.0';

    // Strategy labels
    const strategyLabels = ['Superforecaster', 'Warrior Analyst', 'Trend Follower', 'Mean Reversion', 'Micro Specialist', 'Custom'];
    const riskLabels = ['Conservative', 'Moderate', 'Aggressive'];
    const strategyName = strategyLabels[agent.strategy] || 'Analytical';
    const riskName = riskLabels[agent.riskProfile] || 'Moderate';

    let prompt = `
You are an AI trading agent for the Warriors AI Arena prediction market.
Your strategy is: ${strategyName}
Your risk profile is: ${riskName}

MARKET QUESTION: ${market.question}

CURRENT MARKET STATE:
- Yes probability: ${yesProbability}%
- Total volume: ${formatEther(market.totalVolume)} CRwN
- Liquidity: ${formatEther(market.liquidity)} CRwN
`;

    // Add warrior data only for battle markets
    if (isBattleMarket) {
      prompt += `
WARRIOR 1 (ID: ${w1.id}):
- Strength: ${w1.traits.strength}
- Wit: ${w1.traits.wit}
- Defence: ${w1.traits.defence}
- Luck: ${w1.traits.luck}
- Charisma: ${w1.traits.charisma}

WARRIOR 2 (ID: ${w2.id}):
- Strength: ${w2.traits.strength}
- Wit: ${w2.traits.wit}
- Defence: ${w2.traits.defence}
- Luck: ${w2.traits.luck}
- Charisma: ${w2.traits.charisma}
`;

      if (context.length > 0) {
        prompt += `\n\nHISTORICAL CONTEXT (${context.length} previous battles):`;
        for (const battle of context.slice(0, 3)) {
          prompt += `\n- Battle #${battle.battleId}: ${battle.outcome} after ${battle.totalRounds} rounds`;
        }
      }
    } else {
      prompt += `
This is a general prediction market. Analyze the question based on:
- Current market sentiment (${yesProbability}% Yes)
- Available information and logical reasoning
- Your ${strategyName} strategy with ${riskName} risk profile
`;
    }

    prompt += `

Based on your analysis, provide your trading prediction in JSON format:
{
  "outcome": "yes" | "no",
  "confidence": <number 0-100>,
  "reasoning": "<your detailed analysis explaining why you chose this position>"
}

IMPORTANT: Your prediction will be verified on-chain. Be accurate and provide clear reasoning.
`;

    return prompt;
  }

  /**
   * Parse AI response to extract prediction
   */
  private parseAIResponse(response: string): {
    outcome: 'yes' | 'no' | 'draw';
    confidence: number;
    reasoning: string;
  } {
    try {
      // Try direct parse
      const parsed = JSON.parse(response.trim());
      return {
        outcome: parsed.outcome || 'draw',
        confidence: parsed.confidence || 50,
        reasoning: parsed.reasoning || 'No reasoning provided'
      };
    } catch {
      // Try to extract from markdown
      const jsonMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
      if (jsonMatch) {
        try {
          const parsed = JSON.parse(jsonMatch[1].trim());
          return {
            outcome: parsed.outcome || 'draw',
            confidence: parsed.confidence || 50,
            reasoning: parsed.reasoning || 'No reasoning provided'
          };
        } catch {}
      }

      // Try to find JSON object
      const objectMatch = response.match(/\{[\s\S]*\}/);
      if (objectMatch) {
        try {
          const parsed = JSON.parse(objectMatch[0]);
          return {
            outcome: parsed.outcome || 'draw',
            confidence: parsed.confidence || 50,
            reasoning: parsed.reasoning || 'No reasoning provided'
          };
        } catch {}
      }

      return {
        outcome: 'draw',
        confidence: 50,
        reasoning: response
      };
    }
  }
}

export const aiAgentTradingService = new AIAgentTradingService();
export default aiAgentTradingService;
