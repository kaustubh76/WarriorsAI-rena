/**
 * Oracle Verification Utilities
 *
 * Verifies that oracle signatures are generated by the authorized oracle address
 * before submitting transactions to prevent silent failures.
 *
 * Usage:
 * ```typescript
 * import { verifyOracleAuthorization, getOracleAddress } from '@/lib/oracleVerification';
 *
 * // Before signing oracle messages
 * await verifyOracleAuthorization(contractAddress, expectedOracleAddress);
 *
 * // Get current oracle address from contract
 * const currentOracle = await getOracleAddress(contractAddress);
 * ```
 */

import { createFlowPublicClient, executeWithFlowFallback } from './flowClient';
import { EXTERNAL_MARKET_MIRROR_ABI } from '@/constants/abis';
import type { Address } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';

/**
 * Get the current oracle address from ExternalMarketMirror contract
 *
 * @param contractAddress - ExternalMarketMirror contract address
 * @returns Current oracle address
 */
export async function getOracleAddress(contractAddress: Address): Promise<Address> {
  try {
    const oracleAddress = await executeWithFlowFallback((client) =>
      client.readContract({
        address: contractAddress,
        abi: EXTERNAL_MARKET_MIRROR_ABI,
        functionName: 'oracleAddress',
      })
    );

    return oracleAddress as Address;
  } catch (error) {
    console.error('[OracleVerification] Error getting oracle address:', error);
    throw new Error('Failed to fetch oracle address from contract');
  }
}

/**
 * Verify that the private key matches the authorized oracle address
 *
 * @param contractAddress - ExternalMarketMirror contract address
 * @param privateKey - Private key to verify
 * @returns Object with verification result and details
 */
export async function verifyOracleAuthorization(
  contractAddress: Address,
  privateKey: `0x${string}`
): Promise<{
  isAuthorized: boolean;
  currentOracle: Address;
  signerAddress: Address;
  error?: string;
}> {
  try {
    // Get address from private key
    const account = privateKeyToAccount(privateKey);
    const signerAddress = account.address;

    // Get current oracle address from contract
    const currentOracle = await getOracleAddress(contractAddress);

    // Compare addresses (case-insensitive)
    const isAuthorized =
      signerAddress.toLowerCase() === currentOracle.toLowerCase();

    if (!isAuthorized) {
      return {
        isAuthorized: false,
        currentOracle,
        signerAddress,
        error: `Oracle mismatch: signer=${signerAddress}, authorized=${currentOracle}`,
      };
    }

    return {
      isAuthorized: true,
      currentOracle,
      signerAddress,
    };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';

    return {
      isAuthorized: false,
      currentOracle: '0x0000000000000000000000000000000000000000',
      signerAddress: '0x0000000000000000000000000000000000000000',
      error: errorMessage,
    };
  }
}

/**
 * Assert that oracle is authorized, throwing an error if not
 *
 * @param contractAddress - ExternalMarketMirror contract address
 * @param privateKey - Private key to verify
 * @throws Error if oracle is not authorized
 */
export async function assertOracleAuthorized(
  contractAddress: Address,
  privateKey: `0x${string}`
): Promise<void> {
  const result = await verifyOracleAuthorization(contractAddress, privateKey);

  if (!result.isAuthorized) {
    throw new Error(
      `Oracle authorization failed: ${result.error}\n` +
        `Current authorized oracle: ${result.currentOracle}\n` +
        `Your signer address: ${result.signerAddress}\n` +
        `Please update PRIVATE_KEY environment variable to match the authorized oracle.`
    );
  }

  console.log(
    `[OracleVerification] ✅ Oracle authorized: ${result.signerAddress}`
  );
}

/**
 * Monitor oracle address changes via OracleUpdated events
 *
 * @param contractAddress - ExternalMarketMirror contract address
 * @param onOracleChanged - Callback when oracle address changes
 * @returns Unwatch function
 */
export function watchOracleChanges(
  contractAddress: Address,
  onOracleChanged: (oldOracle: Address, newOracle: Address) => void
) {
  const client = createFlowPublicClient();

  const unwatch = client.watchContractEvent({
    address: contractAddress,
    abi: EXTERNAL_MARKET_MIRROR_ABI,
    eventName: 'OracleUpdated',
    onLogs: (logs) => {
      for (const log of logs) {
        const { oldOracle, newOracle } = log.args as {
          oldOracle: Address;
          newOracle: Address;
        };

        console.warn(
          `[OracleVerification] ⚠️ ORACLE CHANGED: ${oldOracle} → ${newOracle}`
        );

        onOracleChanged(oldOracle, newOracle);
      }
    },
    onError: (error) => {
      console.error('[OracleVerification] Error watching oracle changes:', error);
    },
  });

  console.log('[OracleVerification] Started watching for oracle changes');

  return unwatch;
}

/**
 * Cache for oracle address to reduce RPC calls
 * TTL: 5 minutes
 */
const oracleCache = new Map<
  Address,
  { address: Address; timestamp: number }
>();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * Get oracle address with caching
 *
 * @param contractAddress - ExternalMarketMirror contract address
 * @param forceRefresh - Force refresh cache
 * @returns Cached or fresh oracle address
 */
export async function getOracleAddressCached(
  contractAddress: Address,
  forceRefresh = false
): Promise<Address> {
  const now = Date.now();
  const cached = oracleCache.get(contractAddress);

  // Return cached if valid and not forcing refresh
  if (!forceRefresh && cached && now - cached.timestamp < CACHE_TTL) {
    return cached.address;
  }

  // Fetch fresh oracle address
  const oracleAddress = await getOracleAddress(contractAddress);

  // Update cache
  oracleCache.set(contractAddress, {
    address: oracleAddress,
    timestamp: now,
  });

  return oracleAddress;
}

/**
 * Clear oracle address cache
 * Call this when oracle changes are detected
 */
export function clearOracleCache(contractAddress?: Address): void {
  if (contractAddress) {
    oracleCache.delete(contractAddress);
    console.log(`[OracleVerification] Cleared cache for ${contractAddress}`);
  } else {
    oracleCache.clear();
    console.log('[OracleVerification] Cleared all oracle address cache');
  }
}
